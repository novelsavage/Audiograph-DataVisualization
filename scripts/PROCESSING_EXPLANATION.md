# 処理の説明とランキングロジック

## 1. ネットワークデータ構築処理でのAPI通信

### はい、大量のAPI通信が発生しています

`build_network_data()`関数内の処理（177-191行目で表示されている部分）では、**各アーティストごとに複数のAPI呼び出し**が行われています：

#### 各アーティストあたりのAPI呼び出し

1. **`get_artist_tracks(artist_id, limit=100)`** が呼び出される
   - この関数内で以下のAPI呼び出しが発生：

2. **`sp.artist_albums(artist_id)`** - 1リクエスト
   - アーティストのアルバムとシングルを取得

3. **`sp.album_tracks(album_id)`** - 平均3-5リクエスト（アルバム数による）
   - 各アルバムのトラックリストを取得

4. **`sp.tracks(track_ids)`** - 1-2リクエスト（100曲を50曲ずつバッチ処理）
   - トラックの詳細情報（人気度など）を取得

**合計: 各アーティストあたり約5-8リクエスト**

#### 1000アーティスト処理の場合

- **約5,000-8,000リクエスト**が発生
- これが処理時間がかかる主な原因です

---

## 2. 現在のランキング/抽出ロジック

### 現在のロジック（問題点あり）

```
1. ジャンル検索（search_japanese_artists）
   ↓
   - 15ジャンルから各50アーティストを検索
   - 合計最大750アーティストを取得
   - 検索結果は「関連性」でソートされる（人気度順ではない）

2. 人気度でソート
   ↓
   - 取得したアーティストをpopularityでソート
   - 上位1000人を選択

3. ネットワーク構築
   ↓
   - 各アーティストの楽曲を取得
   - フィーチャリング関係を抽出
```

### 問題点

1. **ジャンル検索は「関連性」でソートされる**
   - Spotify APIの`search`エンドポイントは、検索クエリとの関連性でソート
   - 必ずしも人気度順ではない
   - チャート上位のアーティストが含まれない可能性がある

2. **ジャンルタグが正確でない可能性**
   - アーティストのジャンルタグは、Spotifyが自動的に付与
   - 実際のチャート上位アーティストが適切なタグを持っていない可能性

3. **最新のチャート情報を取得できない**
   - Spotify APIには直接チャートAPIがない
   - プレイリストから取得する必要がある

---

## 3. 改善案：最新チャートから取得する方法

### 方法A: Spotifyプレイリストから取得（推奨）

Spotifyには公式のチャートプレイリストがあります：

- **Japan Top 50** (週間)
- **Japan Viral 50** (バイラル)
- **Tokyo Super Hits** (地域別)

これらのプレイリストからトラックを取得し、アーティストを抽出する方法：

```python
def get_top_artists_from_playlist(playlist_id: str, limit: int = 1000) -> List[Dict]:
    """
    Spotifyプレイリストからトップアーティストを取得
    
    Args:
        playlist_id: プレイリストID（例: "37i9dQZEVXbKXQ4mDTEBXq" - Japan Top 50）
        limit: 取得するアーティスト数
    
    Returns:
        アーティスト情報のリスト（人気度順）
    """
    # プレイリストのトラックを取得
    tracks = sp.playlist_tracks(playlist_id, limit=100)
    
    # トラックからアーティストを抽出
    artists = {}
    for track in tracks['items']:
        for artist in track['track']['artists']:
            artist_id = artist['id']
            if artist_id not in artists:
                # アーティストの詳細情報を取得
                artist_info = sp.artist(artist_id)
                artists[artist_id] = artist_info
    
    # 人気度でソート
    sorted_artists = sorted(artists.values(), key=lambda x: x['popularity'], reverse=True)
    return sorted_artists[:limit]
```

### 方法B: 複数のプレイリストから取得

複数のプレイリストを組み合わせて、より包括的なリストを作成：

```python
JAPAN_CHART_PLAYLISTS = [
    "37i9dQZEVXbKXQ4mDTEBXq",  # Japan Top 50
    "37i9dQZEVXbMDoHDwVN2tF",  # Japan Viral 50
    "37i9dQZF1DXdbkmlag3hbc",  # Tokyo Super Hits
    # その他の日本のプレイリスト
]
```

### 方法C: 人気度で直接検索（改善版）

現在の方法を改善：

1. **より多くのアーティストを取得**（ジャンル検索で）
2. **人気度で厳密にソート**
3. **重複を除去**
4. **上位1000人を選択**

---

## 4. 推奨実装

### ハイブリッドアプローチ

1. **プレイリストからトップアーティストを取得**（最新チャート）
2. **ジャンル検索で補完**（プレイリストに含まれないアーティストも含める）
3. **人気度で統合・ソート**
4. **上位1000人を選択**

これにより：
- ✅ 最新のチャート情報を反映
- ✅ より包括的なアーティストリスト
- ✅ 明確なランキング基準（人気度）

---

## 5. 処理時間の最適化

現在の処理時間が長い理由：
- 各アーティストあたり5-8リクエスト × 1000アーティスト = 5,000-8,000リクエスト

### 最適化案

1. **バッチ処理の活用**（既に実装済み）
   - `sp.tracks()`で50曲ずつ取得

2. **並列処理**（注意が必要）
   - 複数のアーティストを並列に処理
   - ただし、レート制限に注意

3. **キャッシュの活用**
   - 一度取得したアーティスト情報をキャッシュ
   - 再実行時の高速化

4. **取得楽曲数の調整**
   - 100曲 → 50曲に減らすと、処理時間が約半分に

